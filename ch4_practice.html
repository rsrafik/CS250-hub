<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Chapter 4 - Practice Problems</title>
    <link
      href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;600;700&family=Rajdhani:wght@400;600;700&display=swap"
      rel="stylesheet"
    />
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "IBM Plex Mono", monospace;
        background: linear-gradient(135deg, #2e1a2e 0%, #3e2141 100%);
        color: #f3e8ff;
        padding: 30px;
        line-height: 1.6;
      }

      .container {
        max-width: 1100px;
        margin: 0 auto;
        background: rgba(30, 14, 46, 0.95);
        border-radius: 12px;
        padding: 40px;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.6);
      }

      h1 {
        text-align: center;
        font-family: "Rajdhani", sans-serif;
        font-size: 3em;
        color: #a855f7;
        margin-bottom: 10px;
        text-transform: uppercase;
        letter-spacing: 4px;
        text-shadow: 0 0 20px rgba(168, 85, 247, 0.5);
      }

      .subtitle {
        text-align: center;
        color: #c084fc;
        margin-bottom: 40px;
        font-size: 1.3em;
        font-family: "Rajdhani", sans-serif;
      }

      .problem {
        background: rgba(59, 41, 59, 0.8);
        border-left: 5px solid #a855f7;
        border-radius: 8px;
        padding: 25px;
        margin-bottom: 25px;
        position: relative;
      }

      .problem-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 15px;
      }

      .problem-number {
        font-size: 1.5em;
        font-weight: 700;
        color: #a855f7;
        font-family: "Rajdhani", sans-serif;
      }

      .difficulty {
        padding: 5px 15px;
        border-radius: 20px;
        font-size: 0.85em;
        font-weight: 600;
        text-transform: uppercase;
        font-family: "Rajdhani", sans-serif;
      }

      .easy {
        background: #10b981;
        color: white;
      }
      .medium {
        background: #f59e0b;
        color: white;
      }
      .hard {
        background: #ef4444;
        color: white;
      }

      .problem-text {
        font-size: 1.05em;
        margin-bottom: 15px;
        color: #f3e8ff;
      }

      .given {
        background: rgba(168, 85, 247, 0.1);
        border: 1px solid #a855f7;
        border-radius: 5px;
        padding: 15px;
        margin: 15px 0;
        font-size: 0.95em;
      }

      .given-title {
        color: #a855f7;
        font-weight: 600;
        margin-bottom: 8px;
        font-family: "Rajdhani", sans-serif;
      }

      .code-given {
        background: rgba(0, 0, 0, 0.5);
        border: 1px solid #c084fc;
        border-radius: 5px;
        padding: 12px;
        margin: 10px 0;
        font-family: "IBM Plex Mono", monospace;
        color: #c084fc;
        white-space: pre;
        overflow-x: auto;
      }

      .solution {
        background: rgba(16, 185, 129, 0.1);
        border: 2px solid #10b981;
        border-radius: 8px;
        padding: 20px;
        margin-top: 15px;
        display: none;
      }

      .solution.show {
        display: block;
      }

      .solution-header {
        color: #10b981;
        font-weight: 700;
        font-size: 1.1em;
        margin-bottom: 12px;
        text-transform: uppercase;
        font-family: "Rajdhani", sans-serif;
      }

      .solution-step {
        margin-bottom: 10px;
        padding-left: 20px;
        position: relative;
        font-size: 0.95em;
      }

      .solution-step::before {
        content: "‚ñ∏";
        position: absolute;
        left: 0;
        color: #10b981;
        font-weight: bold;
      }

      .code-solution {
        background: rgba(0, 0, 0, 0.6);
        border: 1px solid #10b981;
        border-radius: 5px;
        padding: 12px;
        margin: 10px 0;
        font-family: "IBM Plex Mono", monospace;
        color: #10b981;
        white-space: pre;
        overflow-x: auto;
      }

      .answer-box {
        background: rgba(251, 191, 36, 0.2);
        border: 2px dashed #fbbf24;
        padding: 15px;
        border-radius: 5px;
        margin-top: 10px;
        font-weight: 600;
        color: #fbbf24;
        text-align: center;
        font-size: 1.05em;
      }

      .toggle-btn {
        background: linear-gradient(135deg, #a855f7, #c084fc);
        color: #1a0d2e;
        border: none;
        padding: 10px 20px;
        border-radius: 5px;
        cursor: pointer;
        font-family: "Rajdhani", sans-serif;
        font-weight: 700;
        font-size: 0.95em;
        margin-top: 10px;
        transition: all 0.3s ease;
        text-transform: uppercase;
      }

      .toggle-btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 5px 15px rgba(168, 85, 247, 0.4);
      }

      .section-header {
        background: linear-gradient(90deg, #a855f7, #c084fc);
        color: #1a0d2e;
        padding: 15px;
        border-radius: 8px;
        margin: 35px 0 20px 0;
        font-size: 1.4em;
        font-weight: 700;
        text-transform: uppercase;
        letter-spacing: 2px;
        text-align: center;
        font-family: "Rajdhani", sans-serif;
      }

      .hint {
        background: rgba(236, 72, 153, 0.1);
        border-left: 3px solid #ec4899;
        padding: 10px;
        margin-top: 10px;
        border-radius: 5px;
        font-size: 0.9em;
        color: #ddd;
      }

      .register-hint {
        background: rgba(192, 132, 252, 0.1);
        border: 1px solid #c084fc;
        padding: 8px;
        margin: 8px 0;
        border-radius: 4px;
        font-size: 0.85em;
        color: #c084fc;
      }

      code {
        background: rgba(255, 255, 255, 0.1);
        padding: 2px 6px;
        border-radius: 3px;
        font-family: "IBM Plex Mono", monospace;
        color: #fbbf24;
      }

      @media print {
        .toggle-btn {
          display: none;
        }
        .solution {
          display: block !important;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>üî• PRACTICE PROBLEMS üî•</h1>
      <div class="subtitle">Chapter 4: The Processor</div>

      <div class="section-header">üîß Section 1: Datapath Components</div>

      <div class="problem">
        <div class="problem-header">
          <div class="problem-number">Problem 1</div>
          <div class="difficulty easy">Easy</div>
        </div>
        <div class="problem-text">
          What is the difference between a state element and a combinational
          element? Give two examples of each in the LEGv8 datapath.
        </div>
        <button class="toggle-btn" onclick="toggleSolution(1)">
          Show Solution
        </button>
        <div class="solution" id="solution-1">
          <div class="solution-header">‚úì Solution</div>
          <div class="solution-step">
            <strong>State Elements:</strong> Contain internal storage, outputs
            depend on previous values
          </div>
          <div class="code-solution">
            Characteristics: ‚Ä¢ Have clock input ‚Ä¢ Written at clock edge ‚Ä¢
            Maintain values between cycles ‚Ä¢ Can be read anytime Examples: 1.
            Program Counter (PC) - stores current instruction address 2.
            Register File - stores 32 general-purpose registers 3. Instruction
            Memory - stores program instructions 4. Data Memory - stores program
            data
          </div>
          <div class="solution-step">
            <strong>Combinational Elements:</strong> Output depends ONLY on
            current inputs
          </div>
          <div class="code-solution">
            Characteristics: ‚Ä¢ No internal storage ‚Ä¢ No clock needed ‚Ä¢ Same
            input ‚Üí same output ‚Ä¢ Instant response Examples: 1. ALU - performs
            arithmetic/logic operations 2. Adders - increment PC, calculate
            branch target 3. Multiplexors - select between inputs 4. Sign-Extend
            Unit - extends immediate fields
          </div>
          <div class="answer-box">
            State: Has memory (PC, registers, memories)<br />Combinational: Pure
            logic (ALU, muxes, adders)
          </div>
        </div>
      </div>

      <div class="problem">
        <div class="problem-header">
          <div class="problem-number">Problem 2</div>
          <div class="difficulty medium">Medium</div>
        </div>
        <div class="problem-text">
          Why must the LEGv8 datapath have separate instruction and data
          memories? What would happen if we used a single memory?
        </div>
        <div class="hint">
          üí° Hint: Think about what happens when executing a LDUR instruction
        </div>
        <button class="toggle-btn" onclick="toggleSolution(2)">
          Show Solution
        </button>
        <div class="solution" id="solution-2">
          <div class="solution-header">‚úì Solution</div>
          <div class="solution-step">
            <strong>Fundamental Rule:</strong> No resource can be used more than
            once per clock cycle
          </div>
          <div class="code-solution">
            <strong>LDUR X1, [X2, #20] execution:</strong>

            IF stage: Fetch LDUR instruction from memory ‚Üì ID stage: Decode,
            read X2 from register file ‚Üì EX stage: Calculate address (X2 + 20) ‚Üì
            MEM stage: Read data from memory ‚Üê PROBLEM! ‚Üì WB stage: Write data
            to X1
          </div>
          <div class="solution-step">
            <strong>Conflict in same clock cycle:</strong>
          </div>
          <div class="code-solution">
            Clock Cycle 4: ‚Ä¢ LDUR needs to READ data memory (MEM stage) ‚Ä¢ Next
            instruction needs to READ instruction memory (IF stage) With single
            memory ‚Üí STRUCTURAL HAZARD Cannot do both reads simultaneously!
          </div>
          <div class="solution-step">
            <strong>Solution:</strong> Separate memories allow simultaneous
            access
          </div>
          <div class="answer-box">
            Separate memories prevent structural hazard<br />Allow instruction
            fetch + data access in same cycle
          </div>
        </div>
      </div>

      <div class="section-header">‚ö° Section 2: Pipeline Stages</div>

      <div class="problem">
        <div class="problem-header">
          <div class="problem-number">Problem 3</div>
          <div class="difficulty easy">Easy</div>
        </div>
        <div class="problem-text">
          List the five pipeline stages in order and describe what happens in
          each stage for an <code>ADD X1, X2, X3</code> instruction.
        </div>
        <button class="toggle-btn" onclick="toggleSolution(3)">
          Show Solution
        </button>
        <div class="solution" id="solution-3">
          <div class="solution-header">‚úì Solution</div>
          <div class="code-solution">
            <strong>1. IF (Instruction Fetch):</strong>
            ‚Ä¢ Read ADD instruction from instruction memory ‚Ä¢ Use PC as address ‚Ä¢
            PC = PC + 4 ‚Ä¢ Store instruction in IF/ID register

            <strong>2. ID (Instruction Decode):</strong>
            ‚Ä¢ Decode opcode ‚Üí identify as R-type ADD ‚Ä¢ Read registers X2 and X3
            from register file ‚Ä¢ Generate control signals (RegWrite=1, ALUSrc=0,
            etc.) ‚Ä¢ Store values in ID/EX register

            <strong>3. EX (Execute):</strong>
            ‚Ä¢ ALU adds contents of X2 and X3 ‚Ä¢ ALUOp=10 (R-type), function field
            ‚Üí ADD operation ‚Ä¢ Result stored in EX/MEM register

            <strong>4. MEM (Memory):</strong>
            ‚Ä¢ Nothing happens for ADD (no memory access) ‚Ä¢ Result passes through
            to MEM/WB register ‚Ä¢ MemRead=0, MemWrite=0

            <strong>5. WB (Write Back):</strong>
            ‚Ä¢ Write ALU result to register X1 ‚Ä¢ MemtoReg=0 ‚Üí select ALU result
            (not memory) ‚Ä¢ RegWrite=1 ‚Üí enable write to register file
          </div>
          <div class="answer-box">
            IF ‚Üí ID ‚Üí EX ‚Üí MEM ‚Üí WB<br />ADD uses all 5 stages, MEM stage does
            nothing
          </div>
        </div>
      </div>

      <div class="problem">
        <div class="problem-header">
          <div class="problem-number">Problem 4</div>
          <div class="difficulty medium">Medium</div>
        </div>
        <div class="problem-text">
          Draw a pipeline diagram showing these 4 instructions executing. How
          many clock cycles does it take to execute all 4?
        </div>
        <div class="code-given">
          ADD X1, X2, X3 SUB X4, X1, X5 LDUR X6, [X7, #8] STUR X6, [X8, #16]
        </div>
        <button class="toggle-btn" onclick="toggleSolution(4)">
          Show Solution
        </button>
        <div class="solution" id="solution-4">
          <div class="solution-header">‚úì Solution</div>
          <div class="code-solution">
            Clock Cycle: 1 2 3 4 5 6 7 ----+----+----+----+----+----+----+ ADD:
            IF | ID | EX |MEM | WB | | | SUB: | IF | ID | EX |MEM | WB | | LDUR:
            | | IF | ID | EX |MEM | WB | STUR: | | | IF | ID | EX |MEM |
            Instructions complete WB at: ADD ‚Üí Cycle 5 SUB ‚Üí Cycle 6 LDUR ‚Üí
            Cycle 7 STUR ‚Üí WB not needed (stores don't write registers)
          </div>
          <div class="solution-step">
            <strong>Analysis:</strong>
          </div>
          <div class="code-solution">
            ‚Ä¢ Total cycles = 7 (not 4√ó5=20 for sequential!) ‚Ä¢ Speedup = 20/7 ‚âà
            2.86√ó ‚Ä¢ After initial 5-cycle latency, 1 instruction/cycle ‚Ä¢
            Throughput = 4 instructions / 7 cycles ‚âà 0.57 IPC
          </div>
          <div class="solution-step">
            Pipelining improves <strong>throughput</strong>, not individual
            instruction latency
          </div>
          <div class="answer-box">
            7 clock cycles total<br />Speedup ‚âà 2.86√ó over sequential execution
          </div>
        </div>
      </div>

      <div class="section-header">üéõÔ∏è Section 3: Control Signals</div>

      <div class="problem">
        <div class="problem-header">
          <div class="problem-number">Problem 5</div>
          <div class="difficulty medium">Medium</div>
        </div>
        <div class="problem-text">
          Fill in the control signal values for each instruction type:
        </div>
        <div class="given">
          <div class="given-title">Control Signals:</div>
          Reg2Loc | ALUSrc | MemtoReg | RegWrite | MemRead | MemWrite | Branch |
          ALUOp
        </div>
        <div class="code-given">
          Instructions: 1. ADD X1, X2, X3 2. LDUR X4, [X5, #20] 3. STUR X6, [X7,
          #8] 4. CBZ X8, label
        </div>
        <button class="toggle-btn" onclick="toggleSolution(5)">
          Show Solution
        </button>
        <div class="solution" id="solution-5">
          <div class="solution-header">‚úì Solution</div>
          <div class="code-solution">
            Signal |Reg2Loc|ALUSrc|Mem2Reg|RegWr|MemRd|MemWr|Branch|ALUOp
            -----------|-------|------|-------|-----|-----|-----|------|-----
            ADD (R) | 0 | 0 | 0 | 1 | 0 | 0 | 0 | 10 LDUR (D) | X | 1 | 1 | 1 |
            1 | 0 | 0 | 00 STUR (D) | 1 | 1 | X | 0 | 0 | 1 | 0 | 00 CBZ (CB) |
            1 | 0 | X | 0 | 0 | 0 | 1 | 01
          </div>
          <div class="solution-step">
            <strong>Explanation:</strong>
          </div>
          <div class="code-solution">
            <strong>ADD (R-type):</strong>
            ‚Ä¢ Reg2Loc=0: Read register 2 from Rm field ‚Ä¢ ALUSrc=0: ALU uses
            register data (not immediate) ‚Ä¢ MemtoReg=0: Write ALU result (not
            memory) ‚Ä¢ RegWrite=1: Write to destination register ‚Ä¢ ALUOp=10:
            R-type (check function field)

            <strong>LDUR (Load):</strong>
            ‚Ä¢ Reg2Loc=X: Don't care (only reads 1 register) ‚Ä¢ ALUSrc=1: ALU uses
            immediate offset ‚Ä¢ MemtoReg=1: Write memory data to register ‚Ä¢
            RegWrite=1: Write to destination ‚Ä¢ MemRead=1: Read from memory ‚Ä¢
            ALUOp=00: ADD for address calculation

            <strong>STUR (Store):</strong>
            ‚Ä¢ Reg2Loc=1: Read Rt (data to store) ‚Ä¢ ALUSrc=1: ALU uses immediate
            offset ‚Ä¢ MemtoReg=X: Don't write register ‚Ä¢ RegWrite=0: No register
            write ‚Ä¢ MemWrite=1: Write to memory ‚Ä¢ ALUOp=00: ADD for address

            <strong>CBZ (Branch):</strong>
            ‚Ä¢ Reg2Loc=1: Read Rt to test ‚Ä¢ ALUSrc=0: ALU gets register (passes
            through) ‚Ä¢ RegWrite=0: No register write ‚Ä¢ Branch=1: Conditional
            branch ‚Ä¢ ALUOp=01: Pass input B (for zero test)
          </div>
          <div class="answer-box">
            X = Don't care<br />Different instruction types need different
            control signals
          </div>
        </div>
      </div>

      <div class="problem">
        <div class="problem-header">
          <div class="problem-number">Problem 6</div>
          <div class="difficulty hard">Hard</div>
        </div>
        <div class="problem-text">
          Why is <code>PCSrc</code> a derived signal rather than directly from
          the control unit? What logic generates it?
        </div>
        <button class="toggle-btn" onclick="toggleSolution(6)">
          Show Solution
        </button>
        <div class="solution" id="solution-6">
          <div class="solution-header">‚úì Solution</div>
          <div class="solution-step">
            <strong>PCSrc</strong> selects next PC: PC+4 or branch target
          </div>
          <div class="code-solution">
            PCSrc = Branch AND Zero Where: ‚Ä¢ Branch: Control signal (1 for CBZ
            instruction) ‚Ä¢ Zero: ALU output (1 if register value is 0)
          </div>
          <div class="solution-step">
            <strong>Why derived?</strong> Branch decision requires TWO
            conditions:
          </div>
          <div class="code-solution">
            1. Instruction IS a branch (opcode check) ‚Üí Control unit sets
            Branch=1 2. Branch condition IS met (register is zero) ‚Üí ALU sets
            Zero=1 Both must be true to take the branch!
          </div>
          <div class="solution-step">
            <strong>Example:</strong>
          </div>
          <div class="code-solution">
            CBZ X5, label // X5 contains 42 Branch = 1 (it's a CBZ instruction)
            Zero = 0 (X5 ‚â† 0) PCSrc = 1 AND 0 = 0 ‚Üí Don't take branch, PC = PC +
            4 If X5 contained 0: Branch = 1 Zero = 1 PCSrc = 1 AND 1 = 1 ‚Üí Take
            branch, PC = branch target
          </div>
          <div class="answer-box">
            PCSrc = Branch AND Zero<br />Needs both: (1) CBZ instruction AND (2)
            register is zero
          </div>
        </div>
      </div>

      <div class="section-header">‚ö†Ô∏è Section 4: Data Hazards</div>

      <div class="problem">
        <div class="problem-header">
          <div class="problem-number">Problem 7</div>
          <div class="difficulty medium">Medium</div>
        </div>
        <div class="problem-text">
          Identify all data hazards in this code sequence. Which can be resolved
          by forwarding? Which require stalling?
        </div>
        <div class="code-given">
          ADD X1, X2, X3 SUB X4, X1, X5 AND X6, X1, X7 LDUR X8, [X1, #0] ORR X9,
          X8, X10
        </div>
        <button class="toggle-btn" onclick="toggleSolution(7)">
          Show Solution
        </button>
        <div class="solution" id="solution-7">
          <div class="solution-header">‚úì Solution</div>
          <div class="code-solution">
            <strong>Hazard 1: ADD ‚Üí SUB (on X1)</strong>
            ADD: WB at cycle 5 SUB: Needs X1 in EX at cycle 4 Forward from
            EX/MEM to ALU input ‚úì

            <strong>Hazard 2: ADD ‚Üí AND (on X1)</strong>
            ADD: WB at cycle 5 AND: Needs X1 in EX at cycle 5 Forward from
            MEM/WB to ALU input ‚úì

            <strong>Hazard 3: ADD ‚Üí LDUR (on X1)</strong>
            ADD: WB at cycle 5 LDUR: Needs X1 in EX at cycle 6 No hazard -
            normal register file read ‚úì

            <strong>Hazard 4: LDUR ‚Üí ORR (on X8)</strong>
            LDUR: Data ready in MEM/WB at cycle 8 ORR: Needs X8 in EX at cycle 7
            LOAD-USE HAZARD - MUST STALL! ‚úó
          </div>
          <div class="solution-step">
            <strong>Why can't forward LDUR ‚Üí ORR?</strong>
          </div>
          <div class="code-solution">
            Timeline: Cycle 7: LDUR in MEM stage (data not loaded yet!) ORR in
            EX stage (needs data NOW) Data doesn't exist yet - cannot forward!
            Must insert 1-cycle bubble (stall)
          </div>
          <div class="answer-box">
            Hazards 1-3: Resolved by forwarding<br />Hazard 4 (Load-Use):
            Requires 1-cycle stall
          </div>
        </div>
      </div>

      <div class="problem">
        <div class="problem-header">
          <div class="problem-number">Problem 8</div>
          <div class="difficulty hard">Hard</div>
        </div>
        <div class="problem-text">
          Write the forwarding conditions in precise notation. When should the
          forwarding unit forward from EX/MEM? From MEM/WB?
        </div>
        <button class="toggle-btn" onclick="toggleSolution(8)">
          Show Solution
        </button>
        <div class="solution" id="solution-8">
          <div class="solution-header">‚úì Solution</div>
          <div class="code-solution">
            <strong>EX Hazard (EX/MEM ‚Üí ID/EX):</strong>

            Forward to ALU input 1 if: EX/MEM.RegWrite = 1 AND EX/MEM.RegisterRd
            ‚â† X31 AND EX/MEM.RegisterRd = ID/EX.RegisterRn1 Forward to ALU input
            2 if: EX/MEM.RegWrite = 1 AND EX/MEM.RegisterRd ‚â† X31 AND
            EX/MEM.RegisterRd = ID/EX.RegisterRm2
          </div>
          <div class="code-solution">
            <strong>MEM Hazard (MEM/WB ‚Üí ID/EX):</strong>

            Forward to ALU input 1 if: MEM/WB.RegWrite = 1 AND MEM/WB.RegisterRd
            ‚â† X31 AND NOT (EX/MEM hazard on same register) AND MEM/WB.RegisterRd
            = ID/EX.RegisterRn1 Forward to ALU input 2 if: MEM/WB.RegWrite = 1
            AND MEM/WB.RegisterRd ‚â† X31 AND NOT (EX/MEM hazard on same register)
            AND MEM/WB.RegisterRd = ID/EX.RegisterRm2
          </div>
          <div class="solution-step">
            <strong>Priority:</strong> EX hazard takes precedence over MEM
            hazard
          </div>
          <div class="code-solution">
            Example: ADD X1, X2, X3 // Cycle 3 (EX/MEM) ADD X1, X4, X5 // Cycle
            4 (MEM/WB) SUB X6, X1, X7 // Cycle 5 (ID/EX, needs X1) Both write
            X1, but EX/MEM has newer value! Forward from EX/MEM, not MEM/WB
          </div>
          <div class="solution-step">
            <strong>Why check RegisterRd ‚â† X31?</strong> X31 is always zero,
            never written
          </div>
          <div class="answer-box">
            EX hazard: Forward from previous instruction<br />MEM hazard:
            Forward from 2 instructions back<br />EX takes priority!
          </div>
        </div>
      </div>

      <div class="section-header">üîÄ Section 5: Control Hazards</div>

      <div class="problem">
        <div class="problem-header">
          <div class="problem-number">Problem 9</div>
          <div class="difficulty easy">Easy</div>
        </div>
        <div class="problem-text">
          What is the control hazard problem? Why does it occur in pipelined
          processors?
        </div>
        <button class="toggle-btn" onclick="toggleSolution(9)">
          Show Solution
        </button>
        <div class="solution" id="solution-9">
          <div class="solution-header">‚úì Solution</div>
          <div class="solution-step">
            <strong>Control Hazard:</strong> Don't know which instruction to
            fetch next
          </div>
          <div class="code-solution">
            Problem occurs with branch instructions (CBZ, B): Cycle 1: CBZ X1,
            label (IF stage) Cycle 2: ??? (Need to fetch next instruction) BUT
            branch decision not until cycle 4 (MEM stage)! Which instruction to
            fetch? ‚Ä¢ Sequential (PC + 4)? ‚Ä¢ Branch target (PC + offset)? Don't
            know yet!
          </div>
          <div class="solution-step">
            <strong>Why it happens:</strong> Pipeline must fetch every cycle
          </div>
          <div class="code-solution">
            Fundamental issue: ‚Ä¢ Instruction fetch happens in cycle 1 ‚Ä¢ Branch
            decision happens in cycle 4 ‚Ä¢ 3-cycle gap where we don't know next
            PC!
          </div>
          <div class="solution-step">
            <strong>Solutions:</strong>
          </div>
          <div class="code-solution">
            1. Stall: Wait 3 cycles (slow!) 2. Predict: Guess outcome, flush if
            wrong 3. Delayed branch: Execute next instruction regardless
          </div>
          <div class="answer-box">
            Branch decision takes time<br />But must fetch next instruction
            immediately
          </div>
        </div>
      </div>

      <div class="problem">
        <div class="problem-header">
          <div class="problem-number">Problem 10</div>
          <div class="difficulty medium">Medium</div>
        </div>
        <div class="problem-text">
          Compare 1-bit and 2-bit branch predictors. What is the prediction
          accuracy for a loop that iterates 10 times?
        </div>
        <div class="hint">
          üí° Hint: Loop branch is taken 9 times, not taken once (exit)
        </div>
        <button class="toggle-btn" onclick="toggleSolution(10)">
          Show Solution
        </button>
        <div class="solution" id="solution-10">
          <div class="solution-header">‚úì Solution</div>
          <div class="code-solution">
            <strong>1-Bit Predictor:</strong>

            Loop: // ... loop body ... SUBI X20, X20, #1 CBNZ X20, Loop
            Iterations: 1 2 3 4 5 6 7 8 9 10 Branch: T T T T T T T T T NT
            Predict: NT T T T T T T T T T Correct? ‚úó ‚úì ‚úì ‚úì ‚úì ‚úì ‚úì ‚úì ‚úì ‚úó Accuracy:
            8/10 = 80%
          </div>
          <div class="solution-step">
            <strong>Why 2 misses?</strong>
          </div>
          <div class="code-solution">
            ‚Ä¢ 1st iteration: Bit=0 (predict NT), actual=T ‚Üí MISS Flip bit to 1 ‚Ä¢
            Iterations 2-9: Bit=1 (predict T), actual=T ‚Üí HIT ‚Ä¢ Last iteration:
            Bit=1 (predict T), actual=NT ‚Üí MISS Flip bit to 0 for next loop
            entry
          </div>
          <div class="code-solution">
            <strong>2-Bit Predictor (initial state: Weakly NT):</strong>

            Iterations: 1 2 3 4 5 6 7 8 9 10 Branch: T T T T T T T T T NT
            Predict: WNT WT ST ST ST ST ST ST ST WT Correct? ‚úó ‚úì ‚úì ‚úì ‚úì ‚úì ‚úì ‚úì ‚úì ‚úì
            Accuracy: 9/10 = 90%
          </div>
          <div class="solution-step">
            States: Strongly NT ‚Üí Weakly NT ‚Üí Weakly T ‚Üí Strongly T
          </div>
          <div class="answer-box">
            1-bit: 80% (2 misses)<br />2-bit: 90% (1 miss) - Better for loops!
          </div>
        </div>
      </div>

      <div class="section-header">üí• Section 6: Exceptions</div>

      <div class="problem">
        <div class="problem-header">
          <div class="problem-number">Problem 11</div>
          <div class="difficulty easy">Easy</div>
        </div>
        <div class="problem-text">
          What are the two registers used for exception handling in LEGv8? What
          does each store?
        </div>
        <button class="toggle-btn" onclick="toggleSolution(11)">
          Show Solution
        </button>
        <div class="solution" id="solution-11">
          <div class="solution-header">‚úì Solution</div>
          <div class="code-solution">
            <strong>1. ELR (Exception Link Register) - 64 bits</strong>

            Stores: Address of affected instruction Purpose: Allows OS to
            restart execution after handling Value: PC + 4 (address of NEXT
            instruction) Why PC+4? So we can resume AFTER the excepting
            instruction
          </div>
          <div class="code-solution">
            <strong>2. ESR (Exception Syndrome Register) - 32 bits</strong>

            Stores: Cause of the exception Purpose: Tells OS what type of
            exception occurred Example values: ‚Ä¢ 8 = Undefined instruction ‚Ä¢ 10
            = Arithmetic overflow/underflow ‚Ä¢ 12 = Hardware malfunction
          </div>
          <div class="solution-step">
            <strong>Exception handling sequence:</strong>
          </div>
          <div class="code-solution">
            1. Save PC to ELR 2. Record cause in ESR 3. Set PC to exception
            handler (e.g., 0x1C090000) 4. Flush pipeline (zero control signals)
            5. Handler examines ESR, takes action 6. Return using ELR (if
            recoverable)
          </div>
          <div class="answer-box">
            ELR: WHERE to resume (address)<br />ESR: WHY exception occurred
            (cause code)
          </div>
        </div>
      </div>

      <div class="problem">
        <div class="problem-header">
          <div class="problem-number">Problem 12</div>
          <div class="difficulty hard">Hard</div>
        </div>
        <div class="problem-text">
          What is the difference between precise and imprecise exceptions? Why
          are precise exceptions harder to implement in pipelined processors?
        </div>
        <button class="toggle-btn" onclick="toggleSolution(12)">
          Show Solution
        </button>
        <div class="solution" id="solution-12">
          <div class="solution-header">‚úì Solution</div>
          <div class="code-solution">
            <strong>Precise Exception:</strong> Associated with exact
            instruction that caused it Properties: ‚Ä¢ All instructions BEFORE
            completed ‚Ä¢ ALL instructions AFTER can be restarted ‚Ä¢ State is as if
            executed sequentially ‚Ä¢ ELR points to exact PC
          </div>
          <div class="code-solution">
            <strong>Imprecise Exception:</strong> Not associated with exact
            instruction Properties: ‚Ä¢ Some later instructions may have completed
            ‚Ä¢ Some earlier might not be done ‚Ä¢ Cannot restart cleanly ‚Ä¢ Harder
            to debug, less deterministic
          </div>
          <div class="solution-step">
            <strong>Why precise is harder in pipelines:</strong>
          </div>
          <div class="code-solution">
            Clock 5 example: ADD X1, X2, X3 (WB stage) ‚úì Done SUB X4, X1, X5
            (MEM stage) ‚Üê Exception here! AND X6, X7, X8 (EX stage) ORR X9, X10,
            X11 (ID stage) LDUR X12, [X13, #0] (IF stage) For precise exception:
            ‚Ä¢ Must complete ADD (it's before SUB) ‚Ä¢ Must NOT complete AND, ORR,
            LDUR (after SUB) ‚Ä¢ Must flush those 3 instructions ‚Ä¢ Save state so
            SUB can be restarted Challenge: Multiple instructions in flight!
            Need to track which is "earliest" exception Flush later instructions
            without affecting earlier ones
          </div>
          <div class="solution-step">
            LEGv8 solution: Sort exceptions, interrupt earliest instruction
          </div>
          <div class="answer-box">
            Precise: Exact instruction, clean restart<br />Imprecise:
            Approximate, hard to recover<br />Precise harder: Must manage
            in-flight instructions
          </div>
        </div>
      </div>

      <div class="section-header">üöÄ Section 7: Multiple Issue</div>

      <div class="problem">
        <div class="problem-header">
          <div class="problem-number">Problem 13</div>
          <div class="difficulty medium">Medium</div>
        </div>
        <div class="problem-text">
          What is the difference between static and dynamic multiple issue? Give
          an example processor of each type.
        </div>
        <button class="toggle-btn" onclick="toggleSolution(13)">
          Show Solution
        </button>
        <div class="solution" id="solution-13">
          <div class="solution-header">‚úì Solution</div>
          <div class="code-solution">
            <strong>Static Multiple Issue (VLIW):</strong>

            Decisions made: At compile time by compiler Issue packet: Fixed
            format, wide instruction Hazards: Compiler inserts NOPs Scheduling:
            Compiler reorders instructions Example: Intel Itanium ‚Ä¢ 128-bit
            instruction bundles ‚Ä¢ 3 instructions per bundle ‚Ä¢ Compiler
            guarantees no hazards
          </div>
          <div class="code-solution">
            <strong>Dynamic Multiple Issue (Superscalar):</strong>

            Decisions made: At runtime by hardware Issue packet: Variable,
            determined dynamically Hazards: Hardware detects and resolves
            Scheduling: Hardware reorders (out-of-order) Examples: Intel Core
            i7, AMD Ryzen, Apple M-series ‚Ä¢ 4-6 instructions per cycle ‚Ä¢
            Hardware checks dependencies ‚Ä¢ Dynamic branch prediction
          </div>
          <div class="solution-step">
            <strong>Key Differences:</strong>
          </div>
          <div class="code-solution">
            Aspect | Static (VLIW) | Dynamic (Superscalar)
            ----------------|----------------|--------------------- Who decides
            | Compiler | Hardware When decides | Compile time | Runtime
            Complexity | Simple HW | Complex HW Power | Lower | Higher
            Performance | Predictable | Adapts to data Binary compat | Tied to
            HW | Works on any impl
          </div>
          <div class="answer-box">
            Static: Compiler does work (VLIW)<br />Dynamic: Hardware does work
            (Superscalar)
          </div>
        </div>
      </div>

      <div class="problem">
        <div class="problem-header">
          <div class="problem-number">Problem 14</div>
          <div class="difficulty hard">Hard</div>
        </div>
        <div class="problem-text">
          For a 2-issue static processor (ALU + Load/Store), schedule this code
          for maximum performance:
        </div>
        <div class="code-given">
          Loop: LDUR X1, [X0, #0] ADDI X1, X1, #1 STUR X1, [X0, #0] ADDI X0, X0,
          #8 SUBI X2, X2, #1 CBNZ X2, Loop
        </div>
        <button class="toggle-btn" onclick="toggleSolution(14)">
          Show Solution
        </button>
        <div class="solution" id="solution-14">
          <div class="solution-header">‚úì Solution</div>
          <div class="solution-step">
            <strong>Original dependencies:</strong> Load-use hazard (LDUR ‚Üí
            ADDI)
          </div>
          <div class="code-solution">
            <strong>Scheduled (2-issue: ALU | Load/Store):</strong>

            Cycle | ALU slot | Load/Store slot
            ------|--------------------|----------------- 1 | Loop: nop | LDUR
            X1, [X0, #0] 2 | ADDI X0, X0, #8 | nop 3 | ADDI X1, X1, #1 | nop 4 |
            SUBI X2, X2, #1 | STUR X1, [X0, #-8] 5 | CBNZ X2, Loop | nop 5
            cycles per iteration
          </div>
          <div class="solution-step">
            <strong>Optimizations applied:</strong>
          </div>
          <div class="code-solution">
            1. Move ADDI X0 before ADDI X1 ‚Üí Separates load-use (avoid stall) 2.
            Adjust STUR offset to #-8 ‚Üí Because X0 already incremented 3. Pair
            ALU with Load/Store when possible ‚Üí Cycles 2 and 4 use both slots 4.
            Fill empty slots with nop ‚Üí Required by static issue
          </div>
          <div class="solution-step">
            <strong>Could further improve with loop unrolling!</strong>
          </div>
          <div class="answer-box">
            5 cycles/iteration<br />IPC = 6 instr / 5 cycles = 1.2
          </div>
        </div>
      </div>

      <div class="section-header">‚ö° Section 8: ILP & Speculation</div>

      <div class="problem">
        <div class="problem-header">
          <div class="problem-number">Problem 15</div>
          <div class="difficulty easy">Easy</div>
        </div>
        <div class="problem-text">
          What is ILP (Instruction-Level Parallelism)? What limits how much ILP
          can be exploited?
        </div>
        <button class="toggle-btn" onclick="toggleSolution(15)">
          Show Solution
        </button>
        <div class="solution" id="solution-15">
          <div class="solution-header">‚úì Solution</div>
          <div class="solution-step">
            <strong>ILP:</strong> Parallelism among instructions - executing
            multiple instructions simultaneously
          </div>
          <div class="code-solution">
            Goal: Execute >1 instruction per cycle Methods to increase ILP: ‚Ä¢
            Deeper pipelines (more overlap) ‚Ä¢ Multiple issue (issue >1/cycle) ‚Ä¢
            Out-of-order execution ‚Ä¢ Speculation
          </div>
          <div class="solution-step">
            <strong>Primary Limitations:</strong>
          </div>
          <div class="code-solution">
            1. Data Dependences (True dependences) ADD X1, X2, X3 SUB X4, X1, X5
            // MUST wait for X1 ‚Üí Cannot execute simultaneously 2. Control
            Dependences CBZ X1, label ADD X2, X3, X4 // Don't know if this
            executes ‚Üí Speculation can help 3. Name Dependences
            (Antidependences) STUR X1, [X2, #0] LDUR X1, [X3, #8] // Reuses X1 ‚Üí
            Register renaming eliminates 4. Memory Hierarchy Stalls ‚Ä¢ Cache
            misses ‚Ä¢ Limited ILP can't hide long stalls 5. Limited Hardware
            Resources ‚Ä¢ Finite functional units ‚Ä¢ Register file ports ‚Ä¢ Reorder
            buffer size
          </div>
          <div class="answer-box">
            ILP = Instructions executing in parallel<br />Limited by:
            Dependencies, branches, memory, hardware
          </div>
        </div>
      </div>

      <div class="problem">
        <div class="problem-header">
          <div class="problem-number">Problem 16</div>
          <div class="difficulty medium">Medium</div>
        </div>
        <div class="problem-text">
          Explain how speculation works. What happens if the speculation is
          incorrect?
        </div>
        <button class="toggle-btn" onclick="toggleSolution(16)">
          Show Solution
        </button>
        <div class="solution" id="solution-16">
          <div class="solution-header">‚úì Solution</div>
          <div class="solution-step">
            <strong>Speculation:</strong> Guess outcome to execute ahead, verify
            later
          </div>
          <div class="code-solution">
            <strong>What can be speculated:</strong>
            ‚Ä¢ Branch outcomes (taken/not taken) ‚Ä¢ Load addresses (doesn't alias
            with store) ‚Ä¢ Instruction properties

            <strong>Example - Branch Speculation:</strong>
            CBZ X1, label ADD X2, X3, X4 ‚Üê Speculatively execute SUB X5, X6, X7
            ‚Üê Speculatively execute label: ORR X8, X9, X10 Guess: Branch NOT
            taken Execute ADD and SUB speculatively Buffer results (don't commit
            yet)
          </div>
          <div class="solution-step">
            <strong>If speculation CORRECT:</strong>
          </div>
          <div class="code-solution">
            1. Verify branch condition 2. Commit buffered results to registers
            3. Continue execution normally Performance: Avoided stall!
          </div>
          <div class="solution-step">
            <strong>If speculation WRONG:</strong>
          </div>
          <div class="code-solution">
            1. Detect misprediction 2. FLUSH pipeline (discard ADD, SUB) 3.
            Discard buffered results 4. Fetch correct instruction (ORR) 5.
            Restart from correct path Performance: Worse than if we'd waited!
            Pipeline flushed + wrong work wasted
          </div>
          <div class="solution-step">
            <strong>Hardware Support:</strong>
          </div>
          <div class="code-solution">
            ‚Ä¢ Reorder buffer: Holds speculative results ‚Ä¢ Commit unit: Decides
            when safe to commit ‚Ä¢ Exception handling: Ignore speculative
            exceptions
          </div>
          <div class="answer-box">
            Correct speculation: Performance win<br />Wrong speculation: Flush +
            restart (penalty)
          </div>
        </div>
      </div>

      <div class="section-header">üîß Section 9: Dynamic Scheduling</div>

      <div class="problem">
        <div class="problem-header">
          <div class="problem-number">Problem 17</div>
          <div class="difficulty medium">Medium</div>
        </div>
        <div class="problem-text">
          What is out-of-order execution? How does it differ from out-of-order
          issue?
        </div>
        <button class="toggle-btn" onclick="toggleSolution(17)">
          Show Solution
        </button>
        <div class="solution" id="solution-17">
          <div class="solution-header">‚úì Solution</div>
          <div class="code-solution">
            <strong>Out-of-Order Execution:</strong>

            Instructions execute when operands ready, not in program order
            Example: LDUR X1, [X2, #0] ‚Üê Memory slow (100 cycles) ADD X3, X1, X4
            ‚Üê Stuck waiting for X1 SUB X5, X6, X7 ‚Üê Ready NOW! Out-of-order:
            Execute SUB before ADD Don't stall entire pipeline waiting for load!
          </div>
          <div class="code-solution">
            <strong>Out-of-Order Issue:</strong>

            Instructions issued to execution units in different order than
            fetched Most superscalars are: ‚Ä¢ In-order issue ‚Ä¢ Out-of-order
            execute ‚Ä¢ In-order commit
          </div>
          <div class="solution-step">
            <strong>Key Difference:</strong>
          </div>
          <div class="code-solution">
            Issue: Sending instruction to functional unit Execute: Actually
            performing the operation In-order issue, out-of-order execute: 1.
            Fetch/decode in order 2. Send to reservation stations in order 3.
            Execute from reservation when ready (OoO) 4. Commit results in order
          </div>
          <div class="solution-step">
            <strong>Why in-order commit?</strong>
          </div>
          <div class="code-solution">
            ‚Ä¢ Preserve precise exceptions ‚Ä¢ Maintain sequential semantics ‚Ä¢
            Easier to debug/verify
          </div>
          <div class="answer-box">
            OoO Execution: Run when ready, not program order<br />In-order
            commit: Write results in program order
          </div>
        </div>
      </div>

      <div class="problem">
        <div class="problem-header">
          <div class="problem-number">Problem 18</div>
          <div class="difficulty hard">Hard</div>
        </div>
        <div class="problem-text">
          Explain the roles of reservation stations and the reorder buffer in
          dynamic scheduling.
        </div>
        <button class="toggle-btn" onclick="toggleSolution(18)">
          Show Solution
        </button>
        <div class="solution" id="solution-18">
          <div class="solution-header">‚úì Solution</div>
          <div class="code-solution">
            <strong>Reservation Stations:</strong>

            Purpose: Hold instruction + operands at functional units Location:
            One per functional unit (ALU, Load/Store, etc.) Contents: ‚Ä¢
            Operation (ADD, SUB, etc.) ‚Ä¢ Operand values (if available) ‚Ä¢ Operand
            tags (if waiting for producer) ‚Ä¢ Destination register Function: 1.
            Instruction dispatched to reservation station 2. Captures operands
            from register file or bypass 3. If operand not ready, tag identifies
            producer 4. When producer completes, result forwarded directly 5.
            When all operands ready, execute 6. Result ‚Üí Reorder buffer +
            waiting stations
          </div>
          <div class="code-solution">
            <strong>Reorder Buffer (ROB):</strong>

            Purpose: Buffer results until safe to commit Location: Centralized,
            shared by all units Contents (per entry): ‚Ä¢ Instruction type ‚Ä¢
            Destination register ‚Ä¢ Result value ‚Ä¢ Ready bit Function: 1.
            Allocate ROB entry when instruction issued 2. Track in-order program
            sequence 3. Execute out-of-order, write to ROB 4. Commit from ROB
            head (oldest instruction) 5. When head ready, commit to register
            file 6. Preserve precise exceptions
          </div>
          <div class="solution-step">
            <strong>Together they provide:</strong>
          </div>
          <div class="code-solution">
            Reservation Stations: ‚Ä¢ Register renaming (eliminate WAW, WAR
            hazards) ‚Ä¢ Operand forwarding ‚Ä¢ Out-of-order execution Reorder
            Buffer: ‚Ä¢ In-order commit ‚Ä¢ Precise exceptions ‚Ä¢ Speculative
            execution support ‚Ä¢ True register state
          </div>
          <div class="solution-step">
            <strong>Example:</strong>
          </div>
          <div class="code-solution">
            LDUR X1, [X2, #0] ROB1, RS_LoadStore ADD X3, X1, X4 ROB2, RS_ALU1
            (waits for ROB1) SUB X5, X6, X7 ROB3, RS_ALU2 (ready!) Execution:
            SUB executes first ‚Üí ROB3 LDUR completes ‚Üí ROB1 ‚Üí forwards to
            RS_ALU1 ADD executes ‚Üí ROB2 Commit (in order): ROB1 (LDUR) ‚Üí X1 ROB2
            (ADD) ‚Üí X3 ROB3 (SUB) ‚Üí X5
          </div>
          <div class="answer-box">
            Reservation Stations: Hold & execute<br />Reorder Buffer: Commit in
            order
          </div>
        </div>
      </div>

      <div class="section-header">üéØ Section 10: Performance Analysis</div>

      <div class="problem">
        <div class="problem-header">
          <div class="problem-number">Problem 19</div>
          <div class="difficulty medium">Medium</div>
        </div>
        <div class="problem-text">
          A loop executes 4 instructions per iteration for 100 iterations.
          Compare execution time for: (a) Single-cycle non-pipelined
          (500ps/instruction) (b) 5-stage pipeline (100ps/stage) (c) 2-issue
          superscalar with perfect scheduling
        </div>
        <button class="toggle-btn" onclick="toggleSolution(19)">
          Show Solution
        </button>
        <div class="solution" id="solution-19">
          <div class="solution-header">‚úì Solution</div>
          <div class="solution-step">
            Total instructions = 4 √ó 100 = 400 instructions
          </div>
          <div class="code-solution">
            <strong>(a) Single-Cycle Non-Pipelined:</strong>

            Time per instruction = 500 ps Total time = 400 √ó 500 ps = 200,000 ps
            = 200 ns CPI = 1 Throughput = 1 instruction per 500 ps
          </div>
          <div class="code-solution">
            <strong>(b) 5-Stage Pipeline:</strong>

            Clock cycle = 100 ps Total cycles = 5 (fill) + 400 - 1 (overlap) =
            404 cycles Total time = 404 √ó 100 ps = 40,400 ps = 40.4 ns CPI =
            404/400 = 1.01 (close to ideal 1.0) Speedup vs (a) = 200/40.4 =
            4.95√ó
          </div>
          <div class="code-solution">
            <strong>(c) 2-Issue Superscalar (perfect):</strong>

            Can issue 2 instructions/cycle Total cycles = 5 (fill) + 400/2 - 1 =
            204 cycles Total time = 204 √ó 100 ps = 20,400 ps = 20.4 ns CPI =
            204/400 = 0.51 IPC = 1.96 (close to ideal 2.0) Speedup vs (b) =
            40.4/20.4 = 1.98√ó Speedup vs (a) = 200/20.4 = 9.8√ó
          </div>
          <div class="solution-step">
            <strong>Summary:</strong>
          </div>
          <div class="code-solution">
            Architecture | Time | Speedup -----------------|---------|--------
            Single-cycle | 200 ns | 1.0√ó 5-stage pipeline | 40.4 ns | 4.95√ó
            2-issue super | 20.4 ns | 9.8√ó
          </div>
          <div class="answer-box">
            Pipelining: ~5√ó speedup<br />Superscalar: ~2√ó more over pipeline
          </div>
        </div>
      </div>

      <div class="problem">
        <div class="problem-header">
          <div class="problem-number">Problem 20</div>
          <div class="difficulty hard">Hard</div>
        </div>
        <div class="problem-text">
          Why can't real processors sustain more than 2-3 instructions per
          cycle, even with 6-wide issue? List and explain the main bottlenecks.
        </div>
        <button class="toggle-btn" onclick="toggleSolution(20)">
          Show Solution
        </button>
        <div class="solution" id="solution-20">
          <div class="solution-header">‚úì Solution</div>
          <div class="code-solution">
            <strong>1. Data Dependences (Fundamental Limit)</strong>

            True dependences cannot be eliminated: ADD X1, X2, X3 SUB X4, X1, X5
            ‚Üê MUST wait for X1 AND X6, X4, X7 ‚Üê MUST wait for X4 Chain of
            dependencies = serial execution Limits parallelism to ~2-3 IPC on
            average
          </div>
          <div class="code-solution">
            <strong>2. Control Hazards (Branch Mispredictions)</strong>

            Branches every ~5 instructions Misprediction rate ~2-10% Penalty:
            Flush 10-20 stage pipeline Impact: Wastes ~20-40% of work Can't
            execute past unresolved branch safely
          </div>
          <div class="code-solution">
            <strong>3. Memory Hierarchy Stalls</strong>

            Cache miss rates: ‚Ä¢ L1: 1-5% miss ‚Üí 10-20 cycle penalty ‚Ä¢ L2: 10-20%
            of L1 misses ‚Üí 100+ cycles ‚Ä¢ Main memory: 200-400 cycles Limited ILP
            can't hide 200-cycle stall Memory bandwidth also limited
          </div>
          <div class="code-solution">
            <strong>4. Limited Hardware Resources</strong>

            ‚Ä¢ Register file: Only so many read/write ports 6-issue needs 12
            reads, 6 writes per cycle! ‚Ä¢ Functional units: 2-3 ALUs, 1-2
            Load/Store ‚Ä¢ Reorder buffer: Finite size (128-256 entries) ‚Ä¢
            Reservation stations: Limited per unit
          </div>
          <div class="code-solution">
            <strong>5. Difficulty Finding ILP</strong>

            Hardware/compiler can only look ahead so far: ‚Ä¢ Compiler: ~100s of
            instructions ‚Ä¢ Hardware: ~200 instruction window True ILP often
            separated by 1000s of instructions Can't see that far ahead
            efficiently
          </div>
          <div class="code-solution">
            <strong>6. Power Wall</strong>

            Out-of-order execution is power-hungry: ‚Ä¢ Complex scheduling logic ‚Ä¢
            Large buffers (ROB, RS) ‚Ä¢ Speculative execution wastes power Modern
            trend: Simpler, more efficient cores Better performance-per-watt at
            2-3 IPC than aggressive 4-6 IPC designs
          </div>
          <div class="answer-box">
            Reality check: Dependencies + branches + memory<br />+ power
            constraints limit real IPC to 2-3
          </div>
        </div>
      </div>

      <!-- Study Tips Section -->
      <div
        style="
          background: linear-gradient(
            135deg,
            rgba(16, 185, 129, 0.2),
            rgba(6, 255, 165, 0.1)
          );
          border: 3px solid #10b981;
          border-radius: 12px;
          padding: 30px;
          margin-top: 40px;
        "
      >
        <div
          style="
            text-align: center;
            font-family: 'Rajdhani', sans-serif;
            font-size: 1.8em;
            color: #10b981;
            margin-bottom: 25px;
            text-transform: uppercase;
            letter-spacing: 3px;
            font-weight: 700;
          "
        >
          üéØ COMPREHENSIVE STUDY TIPS
        </div>

        <div
          style="
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            font-size: 0.95em;
            line-height: 2;
          "
        >
          <div>
            <div style="margin-bottom: 10px">
              ‚úì <strong>Five stages</strong> - IF, ID, EX, MEM, WB (in order)
            </div>
            <div style="margin-bottom: 10px">
              ‚úì <strong>State elements</strong> - Have clock: PC, memories,
              registers
            </div>
            <div style="margin-bottom: 10px">
              ‚úì <strong>Combinational</strong> - No clock: ALU, muxes, adders
            </div>
            <div style="margin-bottom: 10px">
              ‚úì <strong>Structural hazard</strong> - Hardware conflict, need
              separate memories
            </div>
            <div style="margin-bottom: 10px">
              ‚úì <strong>Data hazard</strong> - Need data not ready yet, forward
              or stall
            </div>
            <div style="margin-bottom: 10px">
              ‚úì <strong>Control hazard</strong> - Don't know next PC, predict or
              stall
            </div>
            <div style="margin-bottom: 10px">
              ‚úì <strong>Forwarding</strong> - Bypass register file, use pipeline
              data
            </div>
            <div style="margin-bottom: 10px">
              ‚úì <strong>Load-use</strong> - Must stall 1 cycle, data doesn't
              exist yet
            </div>
            <div style="margin-bottom: 10px">
              ‚úì <strong>1-bit predict</strong> - Single history bit, flip when
              wrong
            </div>
            <div style="margin-bottom: 10px">
              ‚úì <strong>2-bit predict</strong> - 4 states, wrong twice to change
              direction
            </div>
            <div style="margin-bottom: 10px">
              ‚úì <strong>Branch flush</strong> - Wrong prediction, zero control
              signals
            </div>
            <div style="margin-bottom: 10px">
              ‚úì <strong>ELR register</strong> - Saves PC for exception return
            </div>
          </div>
          <div>
            <div style="margin-bottom: 10px">
              ‚úì <strong>ESR register</strong> - Records exception cause code
            </div>
            <div style="margin-bottom: 10px">
              ‚úì <strong>Precise exception</strong> - Exact instruction, can
              restart
            </div>
            <div style="margin-bottom: 10px">
              ‚úì <strong>VLIW</strong> - Static multiple issue, compiler
              schedules
            </div>
            <div style="margin-bottom: 10px">
              ‚úì <strong>Superscalar</strong> - Dynamic multiple issue, hardware
              decides
            </div>
            <div style="margin-bottom: 10px">
              ‚úì <strong>ILP</strong> - Instruction-level parallelism, execute
              multiple
            </div>
            <div style="margin-bottom: 10px">
              ‚úì <strong>Out-of-order</strong> - Execute when ready, commit in
              order
            </div>
            <div style="margin-bottom: 10px">
              ‚úì <strong>Speculation</strong> - Guess outcome, buffer results,
              commit/flush
            </div>
            <div style="margin-bottom: 10px">
              ‚úì <strong>Reservation station</strong> - Hold operands at
              functional unit
            </div>
            <div style="margin-bottom: 10px">
              ‚úì <strong>Reorder buffer</strong> - Buffer results, in-order
              commit
            </div>
            <div style="margin-bottom: 10px">
              ‚úì <strong>Loop unrolling</strong> - Multiple iterations, expose
              ILP
            </div>
            <div style="margin-bottom: 10px">
              ‚úì <strong>Register renaming</strong> - Eliminate name dependences
            </div>
            <div style="margin-bottom: 10px">
              ‚úì <strong>Control signals</strong> - 8 total: Reg2Loc, ALUSrc,
              MemtoReg, RegWrite, MemRead, MemWrite, Branch, ALUOp
            </div>
          </div>
        </div>
      </div>
    </div>

    <script>
      function toggleSolution(num) {
        const solution = document.getElementById("solution-" + num);
        const btn = solution.previousElementSibling;

        if (solution.classList.contains("show")) {
          solution.classList.remove("show");
          btn.textContent = "Show Solution";
        } else {
          solution.classList.add("show");
          btn.textContent = "Hide Solution";
        }
      }
    </script>
  </body>
</html>
